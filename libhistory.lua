---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by david.
--- DateTime: 1/27/2023 6:00 AM
---


local lib = { }

function lib.new(tid, cs, vs)
    local history = {
        start = getTime(),
        dateTime = getDateTime(),
        data = {},
        dataSize = 0,
        now = nil,
        maxAmps = "-----",
        maxWatts = "-----",
        throttleId = tid,
        currentSensor = cs,
        voltageSensor = vs,
        pause_start_time = nil,
        cellLowVoltage = {"------","------","------","------","------","------","------","------"}, --the low value of each cell
        log = nil,
        writing = false,
        writingIndex = 0,
        writingCount = 0
    }

    function history.is_paused(rawThrottle, current_time)
        --if history.pause_start_time ~= nil then
        --    print("history.pause_start_time: " .. ((current_time - history.pause_start_time) / 100))
        --else
        --    print("history.pause_start_time is nil")
        --end
        if rawThrottle == -1024 and history.pause_start_time == nil then
            -- throttle is off but hasn't been detected before now
            history.pause_start_time = current_time
            --print("not paused 1")
            return false
        elseif rawThrottle == -1024 and history.pause_start_time ~= nil and
                ((current_time - history.pause_start_time) / 100) < 5 then
            --print("not paused 2")
            return false
        elseif rawThrottle == -1024 and history.pause_start_time ~= nil and
                ((current_time - history.pause_start_time) / 100) > 5 then
            -- throttle is off for more than 5 seconds
            --print("setting pause")
            return true
        elseif rawThrottle > -1024 then
            -- throttle is engaged, clear paused timer
            history.pause_start_time = nil
            --print("not paused 3")
            return false
        end
        --print("paused 4")
        return false -- generic catch all
    end

    function history.len()
        local count = 0
        for i,v in pairs(history.data) do
            count = count + 1
        end
        return count
    end

    function history.printTable(name, t)
        print("*************************************\n")
        print("\n dump of table: " .. name)
        if type(t) == 'table' then
            for i,v in ipairs(t) do
                print("i: " .. i .. " v: ".. v)
            end
            print("*************************************\n")
        elseif type(t) == "number" then
            print("number in place of table: ", t)
        else
            print("t is unknown")
        end

    end

    function history.checkVoltageDataType(v)
        if history.voltageSensor == 'VFAS' and type(v) == 'number' then
            return true
        elseif history.voltageSensor == 'Cels' and type(v) == 'table' then
            return true
        end
        return false
    end

    function history.compareVoltage(v1, v2)
        if  type(v1) == "table" and type(v2 == "table")then
            --history.printTable("v1", v1)
            --history.printTable("v2", v2)
            for i,v in ipairs(v1) do
                if v1[i] ~= v2[i] then
                    return false
                end
            end
        elseif type(v1) == "number" and type(v2) == "number" then
            if v1 ~= v2 then
                return false
            end
        else
            print("Error: v1 type " .. type(v1) .. " != v2 type " .. type(v2))
        end
        return true
    end

    function history.add(now)
        --print("history.dataSize: " .. history.dataSize)

        if not history.checkVoltageDataType(now.voltage) then
            --print("invalid voltage type detected for ", history.voltageSensor)
            return
        end

        if now.rawThrottle == nil or now.amps == nil or now.voltage == nil then
            --print("skipped history")
            return
        end

        if history.dataSize > 0 and now.time == history.data[history.dataSize].time then
            --print("duplicate tick")
            return
        end

        if history.dataSize == 0 or
                now.rawThrottle ~= history.data[history.dataSize].rawThrottle or
                now.amps ~= history.data[history.dataSize].amps or
                not history.compareVoltage(now.voltage, history.data[history.dataSize].voltage)
        then
            --print("added history")
            history.dataSize = history.dataSize + 1
            history.data[history.dataSize] = now
            history.getMaxValues()
        end
    end

    function history.tick()

        local time = getTime()
        local deltaTime = time - history.start
        local now = {} -- placeholder for current data
        now.time = deltaTime
        now["rawThrottle"] = getValue(history.throttleId)
        if history.currentSensor ~= "" then
            now.amps = getValue( history.currentSensor )
        else
            now.amps = 0
        end

        if history.voltageSensor ~= "" then
            now.voltage  = getValue(history.voltageSensor)
        else
            now.voltage = 0
        end
        history.now = now
        if not history.is_paused(now["rawThrottle"], time) then
            history.add(now)
        end
        --print("data dataSize=" .. history.len())
    end

    function history.getTotalVolts()
        -- For voltage sensors that return a table of sensors, add up the cell
        -- voltages to get a total cell voltage.
        -- Otherwise, just return the value
        if history.now ~= nil and history.now.voltage ~= nil then
            if  type(history.now.voltage) == 'number' then
                return history.now.voltage
            elseif type(history.now) == 'table' then
                local volts = 0
                for i,v in ipairs(history.now.voltage) do
                    volts = volts + v
                    if history.cellLowVoltage[i] == nil or
                            history.cellLowVoltage[i] == "------" or
                            history.cellLowVoltage[i] > v then
                        history.cellLowVoltage[i] = v
                    end
                end
                return volts
            end
        end
        return 0
    end

    function history.getMaxValues()
      if history.currentSensor ~= "" then
        if type(history.now.amps) == "number" then
          if type(history.maxAmps) == "string" or (type(history.maxAmps) == "number"
                  and history.now.amps > history.maxAmps) then
            history.maxAmps = history.now.amps
          end
          local watts = history.now.amps * history.getTotalVolts()
          if type(history.maxWatts) == "string" or watts > history.maxWatts then
            history.maxWatts = watts
          end
        end
      end
    end

    function history.write(gvFlightMode, gvBatNumber, finishResetFunc)
        if history.dataSize > 100 then
            if history.writingIndex == 0 then
                history.writing = true
                local batteryNumber = model.getGlobalVariable(gvBatNumber, gvFlightMode)
                local logTime = history.dateTime.year .. history.dateTime.mon .. history.dateTime.day .. "_" .. history.dateTime.hour .. history.dateTime.min
                local logPath = "/LOGS/" .. name .. "_bat_" .. batteryNumber .. "_" .. history.dataSize .. "_" .. logTime .. ".csv"
                history.log = io.open(logPath, "w")
                io.write(history.log,"time,throttle,amps,")
                if history.voltageSensor == 'Cels' then
                    io.write(history.log, "v1,v2,v3,v4,v5,v6,v7,v8\n")
                else
                    io.write(history.log, "voltage\n")
                end
            end
            --print("history.writingIndex: " .. tostring(history.writingIndex))
            --print("history.dataSize: " .. tostring(history.dataSize))
            --print("history.writingCount: " .. tostring(history.writingCount))
            loop_end = history.dataSize
            if history.writingIndex < history.dataSize then
                loop_start = history.writingIndex + 1
                -- figure out where to stop the loop
                local loop_end = history.writingIndex + 100
                if loop_end > history.dataSize then
                    loop_end = history.dataSize
                end

                --print('size: '.. history.dataSize ..' loop_start: ' .. loop_start .. " loop_end: " .. loop_end)

                for i=loop_start, loop_end, 1 do
                    local v = history.data[i]
                    local line = v.time .. "," .. v.rawThrottle .. "," .. v.amps
                    if type(v.voltage) == 'number' then
                        line = line .. "," .. v.voltage
                    elseif type(v.voltage) == 'table' then
                        for j, v_val in pairs(v.voltage) do
                            line = line .. "," .. v_val
                        end
                    else
                        line = line .. "," .. 0
                    end
                    io.write(history.log, line .. "\n")
                end
                --print('after size: '.. history.dataSize ..' loop_start: ' .. loop_start .. " loop_end: " .. loop_end)
            end

            if loop_end == history.dataSize and history.writingCount == 100 then
                --print("end writing")
                io.close(history.log)
                history.writingIndex = 0
                history.writing = false -- we have printed everything possible, return back false for printing status
                finishResetFunc()
                history.writingCount = 0
                return
            end
            history.writingIndex = loop_end
            history.writing = true -- we are still printing, return back true for printing status and the index
            history.writingCount = history.writingCount + 1
            --print("after " .. history.writingIndex .. " " .. tostring(history.writing))
        end
    end

    return history
end

return lib