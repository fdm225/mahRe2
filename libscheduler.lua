---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by david.
--- DateTime: 1/27/2023 6:00 AM
---

local lib = { }

function unpack (t, i)
    i = i or 1
    if t[i] ~= nil then
        return t[i], unpack(t, i + 1)
    end
end

function lib.new()
    local scheduler = {
        --obj = obj or {}
        tasks = {}
    }

    function scheduler.add(name, execute_immediately, interval, f, ...)
        if scheduler.tasks[name] == nil then
            --print("adding task " .. name)
            task = {}
            task['startTime'] = getRtcTime()
            task['interval'] = interval --Interval at which this should be true
            task['last_second'] = -1 -- last interval that the ready flag was set
            task['ready'] = false -- the value as to if this is ready for use
            task['execute_immediately'] = execute_immediately
            task['f'] = f -- the funciton to call
            task['f_args'] = { ... }
            scheduler.tasks[name] = task
        end
    end

    function scheduler.remove(name)
        scheduler.tasks[name] = nil
    end

    function scheduler.tick()
        for varName, task in pairs(scheduler.tasks) do
            local currentTime = getRtcTime()
            local deltaTime = currentTime - task.startTime
            if (task.execute_immediately == false and currentTime ~= task.startTime) or task.execute_immediately then
                if  (deltaTime % task.interval) == 0 and deltaTime > task.last_second then
                    -- only set true once per second
                    task.ready = true
                    task.last_second = deltaTime + 1
                    if task.f then
                        task.f(unpack(task.f_args))
                    end
                    --print(varName .. " " .. deltaTime .. "/" .. task.interval .. " mod: " .. deltaTime % task.interval .. " ready: " .. tostring(task.ready))
                elseif (deltaTime % task.interval) > 0 and deltaTime > task.last_second then
                    -- we are not on time, set false
                    --_G[varName] = false
                    task.ready = false
                end
                --print(varName .. " " .. deltaTime .. "/" .. task.interval .. " mod: " .. deltaTime % task.interval .. " ready: " .. tostring(task.ready))
            end
        end
    end

    function scheduler.check(name)
        if not scheduler.tasks[name] then
            return nil
        end
        ready = scheduler.tasks[name].ready -- save the current state
        scheduler.tasks[name].ready = false -- since we are reading, we want to reset ready
        return ready
    end

    function scheduler.clear(name)
        if scheduler['name'] then
            scheduler.tasks[name].ready = false
        end
    end

    function scheduler.reset()
        for i, v in pairs(scheduler.tasks) do
            if i ~= 'reset_sw' then
                scheduler.tasks[i] = nil
            end
        end
    end

    return scheduler
end

return lib